结果：可以实现个位数含括号的完美四则运算



## 核心逻辑：
1.正常处理行为：因为是4则运算，所以最高优先级就是*/，当新来的符号+-*/还没有入队的时候，判断前面是不是*/，是的话就让前面两个先进行运算，然后自己再进去
	结果（！！！关键！！！）：就能保证后面的特殊处理能按照从后往前不用考虑优先级的方法直接弹出，避免了特殊处理时候的复杂，变得十分好处理。
2.特殊处理()o:
	(：直接入队，直到遇到),)的逻辑能把这个(弹出去
	): 这个可以在遇到 ( 之前无脑的往前进行运算，遇到(之后把 ( 弹出去，而自己通过新的ch=getchar()就能离开这个体系，结果就是顺利的和没有出现过()一样
	o: 这个也是在遇到 o 之前无脑的往前进行运算，遇到o之后就停止，直接输出仅剩的数字就可以了




24.4.5问题：（以后有时间再改）
1.不能进行非个位数的运算，但是这个是由底层逻辑决定了，字符中只有0~9，要想改的话就要改读取方式，读取方式前面要加数字还是符号的判断函数，其他的差不多
2.小问题就是结尾用的是符号，有可能会忘记
3.没有错误反馈


思考方式：
当觉得没有地方入手（没有宏观的整体角度入手）的时候就拿一个例子来进行推导，看看哪里有问题
然后又可以把这个例子分类讨论，比如将符号的前后顺序调换，继续推导改善。
最后这个模型的适配性就越来越好，存留的问题就越来越少，直到没有问题


24.4.4当前的问题：
1.括号中只能有2个--------------------------------->解决
2.括号后面好像不能直接加o，没考虑到这种情况--------->解决
3.括号后面只能加+-，不可加*/   -------------------->解决

有一种方法解决就是将上面这些情况进行单独的if，还有一种比较难的解决方法就是将这些
情况进行总结得到结论，得到一个宏观的结论，但是很难。
我连这里的本质原理都没有摸清楚完，
只摸索出一个模糊本质：就是前后符号的比较，决定行为